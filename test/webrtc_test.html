<!DOCTYPE html>
<html>

<head>
    <title>TS-VMS WebRTC Test</title>
    <script src="mediasoup-client.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background: #121212;
            color: #eee;
            padding: 20px;
        }

        video {
            background: #000;
            width: 100%;
            max-width: 800px;
            border-radius: 8px;
        }

        .controls {
            margin-bottom: 20px;
        }

        input,
        button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #333;
            color: #fff;
        }

        button {
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        #status {
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>

<body>
    <h1>WebRTC Live View Test</h1>
    <div class="controls">
        <input type="text" id="cameraId" placeholder="Camera ID (UUID)" value="6ed6cf65-a421-4f5f-bfa3-363f33dbf23a">
        <input type="text" id="token" placeholder="JWT Token"
            value="eyJhbGciOiJIUzI1NiIsImtpZCI6InYxIiwidHlwIjoiSldUIn0.eyJ0ZW5hbnRfaWQiOiIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDEiLCJzdWIiOiIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDIiLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzcwNDA0MTA4LCJuYmYiOjE3NzAzMTc3MDgsImlhdCI6MTc3MDMxNzcwOCwianRpIjoiOWY2M2JiYWYtODUzZi00OTI1LTlhMGQtNzk3ZjJlYTU4Mjc5In0.SAuKcphqLwZ_IbQv04SLF76lRDawwUKrHU7Xsh4NBck">
        <button onclick="startView()">Start View</button>
        <button onclick="stopView()" style="background:#dc3545">Stop View</button>
    </div>
    <video id="remoteVideo" autoplay playsinline muted></video>
    <div id="status">Ready.</div>

    <div style="margin-top:20px; border-top:1px solid #333; padding-top:10px;">
        <h3>AI Components</h3>
        <button id="btnOverlay" onclick="toggleOverlay()">Enable Overlay</button>
        <button id="btnWeapon" onclick="toggleWeapon()">Weapon AI: OFF</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="../web/overlay_controller.js"></script>
    <script>
        // --- State Variables (Moved to top) ---
        let overlay = null;
        let overlayEnabled = false;
        let weaponEnabled = false;

        let device;
        let transport;
        let cameraID;
        let tenantID;
        let sessionID;

        // Phase 3.4 Stabilization
        let activeRunId = 0;
        let hlsInstance = null;
        let startInFlight = false;
        const activeTimers = new Set();
        const ENABLE_AUTORETRY = false;

        // --- Helper Functions ---

        function toggleOverlay() {
            const video = document.getElementById('remoteVideo');
            if (!overlay) {
                // Ensure OverlayController exists
                if (typeof OverlayController === 'undefined') {
                    console.error("OverlayController not loaded. Check ../web/overlay_controller.js path.");
                    alert("Overlay Controller script missing.");
                    return;
                }
                overlay = new OverlayController(video, "http://localhost:8080/api/v1", document.getElementById('token').value);
                overlay.setWeaponAlertCallback((p) => {
                    console.warn("WEAPON DETECTED:", p);
                    updateStatus("⚠️ WEAPON DETECTED!");
                });
            }

            if (overlayEnabled) {
                overlay.disable();
                overlayEnabled = false;
                document.getElementById('btnOverlay').innerText = "Enable Overlay";
            } else {
                if (!sessionID) {
                    alert("Start video first to get Session ID");
                    return;
                }
                overlay.token = document.getElementById('token').value;
                overlay.enable(sessionID, cameraID, { weapon: weaponEnabled });
                overlayEnabled = true;
                document.getElementById('btnOverlay').innerText = "Disable Overlay";
            }
        }

        function toggleWeapon() {
            weaponEnabled = !weaponEnabled;
            const btn = document.getElementById('btnWeapon');
            btn.innerText = weaponEnabled ? "Weapon AI: ON" : "Weapon AI: OFF";
            btn.style.background = weaponEnabled ? "#dc3545" : "#007bff";

            if (overlay) {
                overlay.weaponEnabled = weaponEnabled;
            }
        }

        async function checkHealth() {
            try {
                const res = await fetch('http://localhost:8080/api/v1/healthz');
                if (res.ok) {
                    const data = await res.json();
                    console.log("Server Health:", data);
                    updateStatus(`Ready. Server: ${data.go_version} / ${data.commit}`);
                }
            } catch (e) {
                console.warn("Health check failed:", e);
            }
        }

        function getTenantIdFromToken(token) {
            try {
                var base64Url = token.split('.')[1];
                var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4) {
                    base64 += '=';
                }
                var jsonPayload = window.atob(base64);
                const payload = JSON.parse(jsonPayload);
                return payload.tenant_id;
            } catch (e) {
                console.error('Token parsing error:', e);
                return '00000000-0000-0000-0000-000000000001';
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function registerTimer(id) {
            activeTimers.add(id);
            return id;
        }

        function clearAllTimers() {
            activeTimers.forEach(id => clearTimeout(id));
            activeTimers.clear();
        }

        // --- Main Functions ---

        async function startView() {
            if (startInFlight) {
                console.warn('Start already in-progress, ignoring click.');
                return;
            }
            startInFlight = true;

            try {
                // 1. New Run ID
                activeRunId++;
                const currentRunId = activeRunId;
                console.log(`RUN ${currentRunId} start`);

                // 2. Hard Stop previous run
                await hardStopPlayback();
                clearAllTimers();

                const id = document.getElementById('cameraId').value.trim();
                let tokenInput = document.getElementById('token').value.trim();

                if (tokenInput.startsWith("Token: ")) tokenInput = tokenInput.replace("Token: ", "");
                if (tokenInput.startsWith("Bearer ")) tokenInput = tokenInput.replace("Bearer ", "");

                const token = tokenInput;
                cameraID = id;

                if (!id || !token) {
                    alert('Camera ID and Token required');
                    return;
                }

                tenantID = getTenantIdFromToken(token);
                sessionID = generateUUID();
                console.log(`RUN ${currentRunId} Tenant: ${tenantID}, Session: ${sessionID}`);

                try {
                    updateStatus(`[Run ${currentRunId}] Joining room...`);
                    // 1. Join Room
                    const joinResp = await fetch(`http://localhost:8080/api/v1/sfu/rooms/${id}/join`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ sessionId: sessionID })
                    });

                    if (currentRunId !== activeRunId) return;

                    if (!joinResp.ok) {
                        let errData = {};
                        try {
                            errData = await joinResp.json();
                            console.error("Join Failed (Structured):", errData);
                        } catch (jsonErr) {
                            console.error("Join Failed (Raw):", joinResp.statusText);
                        }

                        if (errData.fallback_hint) {
                            console.warn(`RUN ${currentRunId} WebRTC failed, falling back to HLS.`);
                            let hlsUrl = errData.fallback_url;
                            if (hlsUrl && hlsUrl.startsWith("/")) {
                                hlsUrl = "http://localhost:8081" + hlsUrl;
                            }
                            fallbackToHLS(cameraID, token, hlsUrl, currentRunId);
                            return;
                        }

                        throw new Error(`Join failed: ${joinResp.status} ${joinResp.statusText} [${errData.error_code || 'UNKNOWN'}]`);
                    }

                    const routerRtpCapabilities = await joinResp.json();

                    // 2. Load Mediasoup Device
                    if (typeof mediasoupClient === 'undefined') throw new Error("mediasoupClient not loaded");
                    device = new mediasoupClient.Device();
                    await device.load({ routerRtpCapabilities });
                    updateStatus('Device loaded.');

                    // 3. Create Transport on Server
                    const transportResp = await fetch(`http://localhost:8080/api/v1/sfu/rooms/${id}/transports`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });

                    if (!transportResp.ok) throw new Error('Create transport failed');
                    const transportInfo = await transportResp.json();

                    transport = device.createRecvTransport(transportInfo);

                    transport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                        if (currentRunId !== activeRunId) return;
                        try {
                            await fetch(`http://localhost:8080/api/v1/sfu/transports/${transport.id}/connect`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${token}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ dtlsParameters })
                            });
                            callback();
                        } catch (error) {
                            console.error("Transport connect failed:", error);
                            errback(error);
                            if (ENABLE_AUTORETRY) fallbackToHLS(cameraID, token, null, currentRunId);
                        }
                    });

                    transport.on('connectionstatechange', (state) => {
                        console.log('Transport State:', state);
                        if (state === 'failed' || state === 'disconnected') {
                            console.warn('Transport failed, switching to HLS...');
                            fallbackToHLS(cameraID, token);
                        }
                    });

                    // 5s ICE Timeout
                    const watchdogId = setTimeout(() => {
                        if (transport && (transport.connectionState !== 'connected' && transport.connectionState !== 'completed')) {
                            console.warn('ICE Timeout (5s).');
                            if (currentRunId === activeRunId && ENABLE_AUTORETRY) fallbackToHLS(cameraID, token, null, currentRunId);
                        }
                    }, 5000);
                    registerTimer(watchdogId);

                    // 5. Consume Video Stream
                    const consumeUrl = `http://localhost:8080/api/v1/sfu/rooms/${id}/transports/${transport.id}/consume`;
                    console.log("Consuming from:", consumeUrl);
                    const consumeResp = await fetch(consumeUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ rtpCapabilities: device.rtpCapabilities })
                    });

                    if (currentRunId !== activeRunId) return;

                    if (!consumeResp.ok) {
                        const errText = await consumeResp.text();
                        throw new Error(`Consume failed: ${consumeResp.status} ${consumeResp.statusText} - ${errText}`);
                    }
                    const consumerInfo = await consumeResp.json();

                    const consumer = await transport.consume({
                        id: consumerInfo.id,
                        producerId: consumerInfo.producerId,
                        kind: consumerInfo.kind,
                        rtpParameters: consumerInfo.rtpParameters,
                        appData: { jitterBufferTarget: 300, jitterBufferMaxPackets: 200 }
                    });

                    const video = document.getElementById('remoteVideo');
                    video.srcObject = new MediaStream([consumer.track]);

                    try {
                        await video.play();
                        updateStatus(`[Run ${currentRunId}] Streaming live via WebRTC. SUCCESS.`);
                        console.log(`RUN ${currentRunId} mode=webrtc SUCCESS`);
                        clearAllTimers();

                        // Quality Monitor
                        let qualityCheckCount = 0;
                        const qualityTimerId = setInterval(() => {
                            if (currentRunId !== activeRunId) { clearInterval(qualityTimerId); return; }

                            const vWidth = video.videoWidth;
                            const vHeight = video.videoHeight;
                            let frames = 0;
                            if (video.getVideoPlaybackQuality) {
                                frames = video.getVideoPlaybackQuality().totalVideoFrames;
                            } else if (video.webkitDecodedFrameCount) {
                                frames = video.webkitDecodedFrameCount;
                            }

                            console.log(`[Run ${currentRunId}] Stats: ${vWidth}x${vHeight}, frames=${frames}`);

                            if (qualityCheckCount < 3) {
                                qualityCheckCount++;
                            } else {
                                if ((vWidth === 0 || vHeight === 0) || frames === 0) {
                                    console.warn(`[Run ${currentRunId}] Black screen detected. Fallback to HLS.`);
                                    clearInterval(qualityTimerId);
                                    if (currentRunId === activeRunId) fallbackToHLS(cameraID, token, null, currentRunId);
                                } else {
                                    clearInterval(qualityTimerId);
                                }
                            }
                        }, 1000);
                        registerTimer(qualityTimerId);

                    } catch (playErr) {
                        console.error("Play error:", playErr);
                    }

                } catch (e) {
                    if (currentRunId !== activeRunId) return;
                    console.error(`RUN ${currentRunId} Error:`, e);
                    updateStatus('Error: ' + e.message + (ENABLE_AUTORETRY ? '. Retrying...' : '.'));
                    if (ENABLE_AUTORETRY) fallbackToHLS(cameraID, token, null, currentRunId);
                }
            } finally {
                startInFlight = false;
            }
        }

        async function fallbackToHLS(cameraID, token, overrideUrl, runId) {
            if (runId !== activeRunId || (runId === undefined && activeRunId > 0)) {
                return;
            }

            if (transport) {
                transport.close();
                transport = null;
            }

            const video = document.getElementById('remoteVideo');
            video.srcObject = null;

            updateStatus(`[Run ${runId}] Streaming live (HLS Fallback).`);
            console.log(`RUN ${runId} mode=hls`);

            let sessionID;
            let hlsUrl = overrideUrl;
            let queryParams = "";
            const tenantID = getTenantIdFromToken(token);
            const secret = "dev-hls-secret";
            const exp = Math.floor(Date.now() / 1000) + (60 * 60);
            const kid = "v1";

            if (!hlsUrl) {
                try {
                    const sessionRes = await fetch(`http://localhost:8081/hls/session/${cameraID}`);
                    if (!sessionRes.ok) throw new Error("No active HLS session");
                    const sessionData = await sessionRes.json();
                    sessionID = sessionData.session_id;
                } catch (e) {
                    console.error("HLS Session Error:", e);
                    updateStatus("HLS Failed: No active session");
                    return;
                }

                const canonical = `hls|${cameraID}|${sessionID}|${exp}`;

                const encoder = new TextEncoder();
                const keyData = encoder.encode(secret);
                const msgData = encoder.encode(canonical);
                const cryptoKey = await crypto.subtle.importKey(
                    "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
                );
                const signature = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
                const sigHex = Array.from(new Uint8Array(signature))
                    .map(b => b.toString(16).padStart(2, "0"))
                    .join("");

                queryParams = `sub=${cameraID}&sid=${sessionID}&exp=${exp}&scope=hls&kid=${kid}&sig=${sigHex}`;
                hlsUrl = `http://localhost:8081/hls/live/${tenantID}/${cameraID}/${sessionID}/playlist.m3u8?${queryParams}`;
            } else {
                // Use provided URL, ensure signature if needed
                // For now, assume provided URL is valid or already signed if it came from backend? 
                // Backend EnsureHlsSession does NOT sign it usually.
                // So we should try to sign it if we can extract params.
                const parts = hlsUrl.split('/');
                if (parts.length >= 4) {
                    sessionID = parts[parts.length - 2];
                    const canonical = `hls|${cameraID}|${sessionID}|${exp}`;
                    const encoder = new TextEncoder();
                    const keyData = encoder.encode(secret);
                    const msgData = encoder.encode(canonical);
                    const cryptoKey = await crypto.subtle.importKey(
                        "raw", keyData, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
                    );
                    const signature = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
                    const sigHex = Array.from(new Uint8Array(signature))
                        .map(b => b.toString(16).padStart(2, "0"))
                        .join("");

                    queryParams = `sub=${cameraID}&sid=${sessionID}&exp=${exp}&scope=hls&kid=${kid}&sig=${sigHex}`;
                    hlsUrl += (hlsUrl.includes('?') ? '&' : '?') + queryParams;
                }
            }

            console.log("Loading HLS URL:", hlsUrl);

            if (Hls.isSupported()) {
                if (hlsInstance) hlsInstance.destroy();
                const hls = new Hls({
                    xhrSetup: function (xhr, url) {
                        try { xhr.setRequestHeader("Authorization", `Bearer ${token}`); } catch (e) { }
                        if (url.includes('.mp4') && !url.includes('sig=')) {
                            const separator = url.includes('?') ? '&' : '?';
                            xhr.open('GET', url + separator + queryParams);
                        }
                    }
                });
                hlsInstance = hls;
                hls.loadSource(hlsUrl);
                hls.attachMedia(video);
                hls.on(Hls.Events.MANIFEST_PARSED, function () {
                    if (runId === activeRunId) video.play().catch(() => { });
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = hlsUrl;
                if (runId === activeRunId) video.play().catch(() => { });
            }
        }

        async function hardStopPlayback() {
            const video = document.getElementById('remoteVideo');
            video.pause();
            video.srcObject = null;
            video.src = "";
            video.load();

            if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
            }

            if (transport) {
                transport.close();
                transport = null;
            }

            // Leave Room
            const token = document.getElementById('token').value;
            if (cameraID && token) {
                fetch(`http://localhost:8080/api/v1/sfu/sessions/${cameraID}/leave`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                }).catch(() => { });
            }
        }

        async function stopView() {
            activeRunId++;
            console.log(`RUN ${activeRunId} stop`);
            await hardStopPlayback();
            updateStatus('Stopped.');
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        // Init
        checkHealth();
    </script>
</body>

</html>